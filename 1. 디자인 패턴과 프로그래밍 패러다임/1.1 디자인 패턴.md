### 라이브러리와 프레임워크

**공통점**

공통으로 사용할 수 있는 특정한 기능들을 모듈화한 것

**차이점**

**라이브러리**: 사용자가 컨트롤하는 '도구'로, 폴더명이나 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유로움

**프레임워크**: 폴더명, 파일명 등에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격함. 프레임워크 역시 도구지만, 사용자가 프레임워크를 컨트롤하는 것이 아닌 프레임워크의 틀 안에서 사용자가 도구의 도움을 받음.

## 1.1 디자인 패턴

**디자인 패턴**: 프로그램을 설계할 때 발생했던 문제점들을 객체 간 상호 관계 등을 이용하여 해결할 수 있도록 하나의 규약 형태로 만들어 놓은 것

### 1.1.1 싱글톤 패턴

- 하나의 클래스에 오직 하나의 인스턴스만 만들고, 해당 인스턴스를 다른 모듈들이 공유하며 사용하도록 하는 패턴
- 데이터베이스 연결 모듈에 많이 사용
- 장점: 인스턴스 생성 비용이 줄어듦 / 단점: 의존성이 높아짐

**자바스크립트의 싱글톤 패턴**

자바스크립트에서는 리터럴 {} 또는 new Object로 객체를 생성하게 되면 다른 어떤 객체도 같지 않기에 이 자체만으로 싱글톤 패턴 구현 가능

```js
const obj = {
  a: 27
};

const obj2 = {
  a: 27
};

console.log(obj === obj2); // false.
```

obj와 obj2는 다른 인스턴스를 가짐. 이것도 new Object라는 하나의 클래스에서 나온 단 하나의 인스턴스니 실글톤 패턴이라고 볼 수 있지만, 실제 싱글톤 패턴은 보통 다음과 같은 코드로 구성됨.

```js
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }
  getInstance() {
    return this;
  }
}

const a = new Singleton();
const b = new Singleton();
console.log(a === b); // true
```

위 코드는 Singleton.instance라는 하나의 인스턴스를 가지는 Singleton 클래스를 구현한 모습. 이를 통해 a와 b는 하나의 인스턴스를 가짐

**데이터베이스 연결 모듈**

싱글톤 패턴은 데이터베이스 연결 모듈에 많이 사용됨

```js
const URL = 'mongodb://localhost:~~';
const createConnection = (url) => ({ url: url });

class DB {
  constructor(url) {
    if (!DB.instance) {
      DB.instance = createConnection(url);
    }
    return DB.instance;
  }
  connection() {
    return this.instance;
  }
}

const a = new DB(URL);
const b = new DB(URL);
console.log(a === b); // true
```

이렇게 DB.instance라는 하나의 인스턴스를 기반으로 a, b를 생성 -> 데이터베이스 연결에 관한 인스턴스 생성 비용을 아낄 수 있음.

**mongoose의 싱글톤 패턴**

실제로 싱글톤 패턴은 Node.js에서 MongoDB 데이터베이스를 연결할 때 쓰는 mongoose 모듈에서 볼 수 있음.
mongoose의 데이터베이스를 연결할 때 쓰는 connect()라는 함수는 싱글톤 인스턴스를 반환

```js
// 실제 코드
Mongoose.prototype.connect = function (uri, options, callback) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  const conn = _mongoose.connection;

  return _mongoose._promiseOrCallback(callback, (cb) => {
    conn.openUri(uri, options, (err) => {
      if (err != null) {
        return cb(err);
      }
      return cb(null, _mongoose);
    });
  });
};
```

> _이 코드가 싱글톤 패턴을 구현하는 측면_
>
> 1. 전역 Mongoose 객체: `this instanceof Mongoose ? this : mongoose` connect 메서드를 호출하는 객체가 Mongoose 인스턴스인지 확인하고, 그렇지 않다면 전역 몽구스 객체를 사용하여 애플리케이션 전체에서 하나의 Mongoose 객체만을 사용
>
> 2. 연결 객체: `const conn = _mongoose.connection;` Mongoose의 'connection' 객체를 가져옴
>    이 connection 객체는 데이터베이스와의 연결을 관리하는데, 애플리케이션 전역에서 하나의 연결 객체만을 사용하게 됨.
>    즉, 여러 번 connect 메서드를 호출하더라도 같은 connection 객체를 사용하게 되어 불필요한 중복 연결을 방지
>
> 3. \_promiseOrCallback 메서드: '\_promiseOrCallback'메서드는 Mongoose 내부의 유틸리티 메서드로, 콜백 방식과 프로미스 방식을 동시에 지원
>    이 메서드를 통해 connect 메서드는 프로미스를 반화하거나 콜백을 사용할 수 있게 되어 유연성을 제공하면서도 싱글톤 인스턴스와의 상호작용을 일관되게 유지

**싱글톤 패턴의 단점**

- TDD(Test Driven Development)를 할 때 걸림돌이 됨
  - TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야함
  - 그러나 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 독립적인 인스턴스를 만들기 어려움

**의존성 주입**

메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 주기보다, 중간에 의존선성 주입자가 이 부분을 가로채 메인 모듈이 간접적으로 의존성을 주입하는 방식.

싱글톤 패턴은 모듈 간의 결합을 강하게 만들 수 있는데, 이때 의존성 주입을 통해 해결 가능

\*의존성(=종속성): A가 B에 의존성이 있다 = B의 변경 사항에 A 또한 변해야 한다

- 장점: 의존성 주입을 하면 모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅이 쉽고 / 마이그레이션이 수월 / 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어주기에 애플리케이션 의존성 방향이 일관되고, 쉽게 추론 가능 / 모듈 간의 관계가 명확해짐
- 단점: 모듈들이 더욱 분리되므로 클래스 수가 늘어나 복잡성 능가, 런타임 패널티가 생기기도 함
- 의존성 주입의 원칙: (1) 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 함 (2) 추상화에 의존해야하며 (3) 추상화는 세부 사항에 의존하지 말아야 함

### 1.1.2 팩토리 패턴

객체를 사용하는 코드에서 **객체 생성 부분을 떼어내 추상화한 패턴**이자, **상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴**

- 상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가짐
- 상위 클래스에서는 인스턴스 생성 방식에 대해 알 필요가 없기에 더 많은 유연성을 가짐
- 객체 생성 로직이 따로 떼어져 있기 때문에 유지보수성이 증가

ex) 라떼 아메리카노 우유 레시피라는 구체적인 내용이 들어있는 하위 클래스가 컨베이어 벨트를 통해 전달되고, 상위 클래스인 바리스타 공장에서 이 레시피들을 토대로 우유 등을 생산하는 생산 공정

**자바스크립트의 팩토리 패턴**

```js
const num = new Object(42);
const str = new Object('abc');
num.constructor.name; // Number
str.constructor.name; // String
```

숫자를 전달하거나 문자열을 전달함에 따라 **다른 타입의 객체 생성**

즉, 전달받은 값에 따라 다른 객체를 생성하며 인스턴스의 타입 등을 정함.

ex) 커피 팩토리를 기반으로 라뗴 등을 생산하는 코드

```js
class CoffeeFactory { // CoffeeFactory라는 이름의 클래스를 정의
  static createCoffee(type) { // 클래스 메서드로 type에 따라 적절한 커피를 생성하는 메서드
    const factory = factoryList[type] // factoryList 객체에서 type에 해당하는 값을 가져와 factory 변수에 저장
    return factory.createCoffee() // factory의 createCoffee 메서드를 호출하여 생성된 커피 객체를 반환
  }
}

class Latte { // Latte라는 이름의 클래스를 정의
  constructor() { // 객체를 생성할 때 호출되는 생성자 메서드
    this.name = "latte" // Latte 객체의 name 속성을 latte로 설정
  }
}

class Espresso {
  constructor() {
    this.name = "Espresso"
  }
}

class LatteFactory extends CoffeeFactory { // LatteeFactory라는 이름의 클래스를 정의. 이 클래스는 CoffeeFactory를 상속 받음
  static createCoffee() { // LatteFactory의 정적 메서드로, 새로운 Latte 객체를 생성하고 반환
    return new Latte()
  }
}

class EspressoFactory extends CoffeeFactory {
  static createCoffee() {
    return new Espresso()
  }
}

const factoryList = {LatteFactory, EspressoFactory} // factoryList는 LatteFactory와 EspressoFactory를 포함하는 객체.
// 이 객체는 CoffeeFactory.createCoffee 메서드에서 커피를 생성하는데 사용됨

const main = () => {
  // 라떼 커피를 주문한다.
  const coffee = CoffeeFactory.createCoffee("LatteFactory") // CoffeeFactory의 createCoffee 메서드를 호출하여 latteFactory라는 인자로 LatteFactory를 사용해 Latte 객체를 생성
  // 커피 이름을 부른다
  console.log(coffee.name) // latte. 생성된 커피 객체의 name 속성을 출력. 
}
main()
```
CoffeeFactory라는 상위 클래스가 중요한 뼈대를 결정하고 하위 클래스인 LatteFactory가 구체적인 내용을 결정하고 있음.

CoffeeFactory에서 LatteFactory의 인스턴스를 생성하는 것이 아니라, LatteFactory에서 생성한 인스턴스를 CoffeeFactory에 주입하고 있기에 의존성 주입이라고 볼 수도 있음.

또한 CoffeeFactory 클래스를 보면 static 키워드를 통해 createCoffee() 메서드를 정적 메서드로 선언한 것을 볼 수 있는데, 이렇게 정적 메서드로 정의하면 클래스를 기반으로 객체를 만들지 않고 호출이 가능하며, 해당 메서드에 대한 메모리 할당을 한 번만 할 수 있다는 장점이 있음. 

### 1.1.3 전략 패턴

### 1.1.4 옵저버 패턴

### 1.1.5 프록시 패턴과 프록시 서버

### 1.1.6 이터레이터 패턴

### 1.1.7 노출모듈 패턴

### 1.1.8 MVC 패턴

### 1.1.9 MVP 패턴

### 1.1.10 MVVM 패턴
