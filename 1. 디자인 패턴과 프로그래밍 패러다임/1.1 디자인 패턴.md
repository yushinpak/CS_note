### 라이브러리와 프레임워크

**공통점**

공통으로 사용할 수 있는 특정한 기능들을 모듈화한 것

**차이점**

**라이브러리**: 사용자가 컨트롤하는 '도구'로, 폴더명이나 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유로움

**프레임워크**: 폴더명, 파일명 등에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격함. 프레임워크 역시 도구지만, 사용자가 프레임워크를 컨트롤하는 것이 아닌 프레임워크의 틀 안에서 사용자가 도구의 도움을 받음.

## 1.1 디자인 패턴

**디자인 패턴**: 프로그램을 설계할 때 발생했던 문제점들을 객체 간 상호 관계 등을 이용하여 해결할 수 있도록 하나의 규약 형태로 만들어 놓은 것

### 1.1.1 싱글톤 패턴

- 하나의 클래스에 오직 하나의 인스턴스만 만들고, 해당 인스턴스를 다른 모듈들이 공유하며 사용하도록 하는 패턴
- 데이터베이스 연결 모듈에 많이 사용
- 장점: 인스턴스 생성 비용이 줄어듦 / 단점: 의존성이 높아짐

**자바스크립트의 싱글톤 패턴**

자바스크립트에서는 리터럴 {} 또는 new Object로 객체를 생성하게 되면 다른 어떤 객체도 같지 않기에 이 자체만으로 싱글톤 패턴 구현 가능
```js
const obj = {
    a: 27
}

const obj2 = {
    a: 27
}

console.log(obj === obj2)// false.
```
 obj와 obj2는 다른 인스턴스를 가짐. 이것도  new Object라는 하나의 클래스에서 나온 단 하나의 인스턴스니 실글톤 패턴이라고 볼 수 있지만, 실제 싱글톤 패턴은 보통 다음과 같은 코드로 구성됨.
 
```js
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this
    }
    return Singleton.instance
  }
  getInstance() {
    return this
  }
}

const a = new Singleton()
const b = new Singleton()
console.log(a === b) // true
```
위 코드는 Singleton.instance라는 하나의 인스턴스를 가지는 Singleton 클래스를 구현한 모습. 이를 통해 a와 b는 하나의 인스턴스를 가짐

**데이터베이스 연결 모듈**

싱글톤 패턴은 데이터베이스 연결 모듈에 많이 사용됨

```js
const URL = 'mongodb://localhost:~~'
const createConnection = url => ({"url" : url})

class DB {
  constructor(url) {
    if (!DB.instance) {
      DB.instance = createConnection(url)
    }
    return DB.instance
  }
  connection(){
    return this.instance
  }
}

const a = new DB(URL)
const b = new DB(URL)
console.log(a === b) // true
```
이렇게 DB.instance라는 하나의 인스턴스를 기반으로 a, b를 생성 -> 데이터베이스 연결에 관한 인스턴스 생성 비용을 아낄 수 있음. 

**mongoose의 싱글톤 패턴**

실제로 싱글톤 패턴은 Node.js에서 MongoDB 데이터베이스를 연결할 때 쓰는 mongoose 모듈에서 볼 수 있음.
mongoose의 데이터베이스를 연결할 때 쓰는 connect()라는 함수는 싱글톤 인스턴스를 반환

```js
// 실제 코드
Mongoose.prototype.connect = function(uri, options, callback) {
  const _mongoose = this instanceof Mongoose ? this : mongoose; 
  const conn = _mongoose.connection;

  return _mongoose._promiseOrCallback(callback, cb => {
    conn.openUri(uri, options, err => {
      if (err != null) {
        return cb(err);
      }
      return cb(null, _mongoose);
    });
  });
};
```

> *이 코드가 싱글톤 패턴을 구현하는 측면*
>
> 1. 전역 Mongoose 객체: `this instanceof Mongoose ? this : mongoose` connect 메서드를 호출하는 객체가 Mongoose 인스턴스인지 확인하고, 그렇지 않다면 전역 몽구스 객체를 사용하여 애플리케이션 전체에서 하나의 Mongoose 객체만을 사용
>
> 2. 연결 객체: `const conn = _mongoose.connection;` Mongoose의 'connection' 객체를 가져옴
> 이 connection 객체는 데이터베이스와의 연결을 관리하는데, 애플리케이션 전역에서 하나의 연결 객체만을 사용하게 됨.
> 즉, 여러 번 connect 메서드를 호출하더라도 같은 connection 객체를 사용하게 되어 불필요한 중복 연결을 방지
>
> 3. _promiseOrCallback 메서드: '_promiseOrCallback'메서드는 Mongoose 내부의 유틸리티 메서드로, 콜백 방식과 프로미스 방식을 동시에 지원
> 이 메서드를 통해 connect 메서드는 프로미스를 반화하거나 콜백을 사용할 수 있게 되어 유연성을 제공하면서도 싱글톤 인스턴스와의 상호작용을 일관되게 유지

**싱글톤 패턴의 단점**
- TDD(Test Driven Development)를 할 때 걸림돌이 됨
  - TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야함
  - 그러나 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 독립적인 인스턴스를 만들기 어려움

**의존성 주입**

메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 주기보다, 중간에 의존선성 주입자가 이 부분을 가로채 메인 모듈이 간접적으로 의존성을 주입하는 방식.

싱글톤 패턴은 모듈 간의 결합을 강하게 만들 수 있는데, 이때 의존성 주입을 통해 해결 가능

*의존성(=종속성): A가 B에 의존성이 있다 = B의 변경 사항에 A 또한 변해야 한다

  - 장점: 의존성 주입을 하면 모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅이 쉽고 / 마이그레이션이 수월 / 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어주기에 애플리케이션 의존성 방향이 일관되고, 쉽게 추론 가능 / 모듈 간의 관계가 명확해짐
  - 단점: 모듈들이 더욱 분리되므로 클래스 수가 늘어나 복잡성 능가, 런타임 패널티가 생기기도 함
  - 의존성 주입의 원칙: (1) 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 함 (2) 추상화에 의존해야하며 (3) 추상화는 세부 사항에 의존하지 말아야 함
### 1.1.2 팩토리 패턴


### 1.1.3 전략 패턴

### 1.1.4 옵저버 패턴

### 1.1.5 프록시 패턴과 프록시 서버

### 1.1.6 이터레이터 패턴

### 1.1.7 노출모듈 패턴

### 1.1.8 MVC 패턴

### 1.1.9 MVP 패턴

### 1.1.10 MVVM 패턴
